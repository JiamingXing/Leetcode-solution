package bfs;

//864 挑战一下比较难的题 离开舒适区
//需要考虑的问题 怎么知道我们收集到了所有的钥匙？ 用一个set..通过set.size()判断是否📱齐，也可以通过set知道我们是否可以解锁lock
//假如在当前状态我们碰到无法解锁的lock...优先的下一步应该是去找到key...走回来解锁
//所以我们走过的地方应该需要记录 但是我们又是可能走回头路的
//存在收集不完所有钥匙的情况需要return -1 那么假如我们回头路回来又碰到锁了还是无法解锁可能就结束了 但是如何判断？

//想想这些限制条件就觉得很难但是思考一下如何解决上述所说需要考虑的问题
//大体思路肯定是BFS 因为需要知道min steps
//第一步肯定是遍历整个数组 记录钥匙总数 以及起点位置...
//我们在做BFS的时候每到一个点其实也就知道了 这个点到起点的最小距离
//假设我们是畅通无阻的 也就是不存在锁的事情 我们好像可以知道每个锁以及钥匙对应到原点的最远距离
//也就是说我们最多需要记录12个点到原点的最短距离 并且我们知道是什么样的点有什么样的距离 肯定距离长短

//看到答案 知道别人如何解决最最关键的点 用一个一个点的row,col,以及key的状态组合成一个可以判断是否visit过的点
//handle the visited point for DIFFERENT PATHS - "x y key"

//然后别人是如何track哪些key已经collect了？ 因为这些key是a-f的  所以我们其实只需要用bit来记录就可以了...这点根本想不到

public class ShortestPathtoGetAllKeys {
    public int shortestPathAllKeys(String[] grid) {
        return 1;
    }
}
